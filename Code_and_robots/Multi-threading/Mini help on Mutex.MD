<b>lock</b> – если мьютекс не принадлежит никакому потоку, тогда поток, вызвавший lock, становится его обладателем. Если же некий поток уже владеет мьютексом, то текущий поток(который пытается овладеть им) блокируется до тех пор, пока мьютекс не будет освобожден и у него не появится шанса овладеть им.

<b>try_lock</b> - если мьютекс не принадлежит никакому потоку, тогда поток, вызвавший try_lock, становится его обладателем и метод возвращает true. В противном случае возвращает false. try_lock не блокирует текущий поток.

<b>unlock</b> – освобождает ранее захваченный мьютекс.

<h1>2 дополнительные для временных(timed) мьютексов</h1>

try_lock_for – расширенная версия try_lock, которая позволяет задать продолжительность ожидания, прежде чем стоит прекратить попытку овладения мьютексом. Т.е. возвращает true в том случае, если удалось овладеть мьютексом в заданный промежуток времени. В противном случае возвращает false. Принимает std::chrono::duration, в качестве аргумента.

try_lock_until – та же, что предыдущая, но принимает std::chrono::time_point в качестве аргумента.

<h1>4 типа mutex</h1>

<b>mutex</b> – базовый mutex, которым может владеть один поток в единицу времени. При попытке повторного овладения мьютексом, потоком, уже владеющим им, произойдёт deadlock(или будет брошено исключение с кодом ошибки  resource_deadlock_would_occur). 

<b>recursive_mutex</b> – обладает теми же свойствами, что и std::mutex, но позволяет рекурсивное овладение мьютексом, то есть многократный вызов метода lock() в потоке, который владеет мьютексом. При этом, метод unlock() должен быть вызван не меньшее количество раз, чем был вызван lock(). В противном случае вы получите deadlock, т.к. этот поток никогда не освободит мьютекс и остальные потоки будут находиться в вечном ожидании.

<b>timed_mutex</b> – обладая свойствами std::mutex, std::timed_mutex, так же, обладает дополнительными методами позволяющими блокировку на время.

<b>recursive_timed_mutex</b> – рекуррентная версия std::timed_mutex.

<h1>condition_variable</h1>

<b>wait</b> – ставит поток в ожидание сигнала. Ожидание не лимитировано временем. Может принимать в качестве аргумента предикат, от результата которого будет зависеть выход потока из ожидания. Т.е. если даже wait был завершен благодаря сигналу, происходит проверка предиката после чего поток снова становится в ожидание, если предикат ложен. На псевдокоде: (while(!predicate) wait;). А нужно это, в первую очередь, для того, чтобы избежать реагирования на фальшивое(spurious) пробуждение(см. врезку ниже).

<b>wait_for</b> – Ожидание заданное время std::chrono

<b>wait_until</b> - Ожидание до определенной даты

<b>notify_one</b> – Посылает сигнал одному из ожидающих потоков; т.е. разблокирует один поток. Какой поток будет разбужен – не известно. Гарантировано лишь то, что один из них будет.

<b>notify_all</b> – Посылает сигнал всем ожидающим потокам; т.е. разблокирует все потоки ожидающие на данном объекте condition_variable
